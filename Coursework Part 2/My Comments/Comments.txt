Pair 0 - Code Readability 

In the FoxHoundUtils we can see that Student B has method comments on majority of the methods whereas Student A does not have any method comments. For example the method initialisePositions() Student B has commented on what it does generally and have the necessary tags for the variables passed in and what is returned. This helps to the reader to understand generally what the method does and we can see what it will be returning without looking deep into the method and searching for what is returned. For Student A we have to base on the method name to determine what the method is about and no information about what is passed in or returned without looking into the method. One way for Student A to improve is to add method comments for the methods that does not currently have them, this would significantly improve the readability of the code and help others to understand it a little easier. 

The method comments from Student B is helpful as they can easily be seen and help to guide the programmer to see roughly where the method starts. This helps to locate the start of the new method without needing to search for the actual declariation of the method. This will aid the programmer if they are searching for a particular method they can easily skip the body of a method without worrying about going past any. 

From FoxHoundIO, method saveGame we can see that Student A have made clear comments on the exception checking and we can clearly see what they are checking for whereas in Student B (same method) we have to take a closer look and see what they are checking for. This inline comment really helps to compare the code to what its meant to do compared to what it actually does. 

From both Student A and Student B they method names are all well name and "self documented". For example in FoxHoundUtils Student A have the method CoordToStr(), from reading this we can tell that this method will convert a board coordintate to a string. Student B have the method isValidPos(), from this we can tell that this method is checking if the position is a valid one on the board. 

From Student A's isValidMove method we can see that Student A used a boolean variable "k" and an integer variable "q". From just looking at the variable we cannot see what they are intended to store and we have to look deep into the code and try to work out what they are for. They do not fall under the "meaningful names" under the INF1B conventions and are not "self Documenting". Whereas in the same method in Student B's code we can see they used "meaningful names" like "isExist" or "isOccupied". Student A can improve by making the variable names more meaningful and we can easily see what they would contain and their intended use for them within the method. 

Both Student A and B does not have comments for the constants in FoxHoundUtils (Student A: NUM_OF_FOXES and Student B: GRIDS_LETTER, DEFAULT_HOUNDS_ROW). These names are again "self documenting" but by INF1B convention they should have a comment describing their uses and Student A and Student B can imporve by adding a short JavaDoc comment to describe what their intended use is. This helps the person reading the code understand it a bit more of the purpose and what it will be used for. 

Pair 2 - Code Structure 

In Student A's isValidMove method, most calculations are done within the method and only calls upon one other method containsElement(). This makes the code harder to understand the method is doing multiple things compared to just one thing. On the other hand Student B's isValidMove calls upon canMove() and this calls onto more methods to do one calculation each and then it is all compared within canMove(). This makes the code much more modular and helps to understand it a little better as each method only has to do one thing. Student A can improve by splitting up the isValidMove() and call to sub-methods to do some of the calculations and therefore it can be easier to understand as each one would just have one purpose rather than do everything into one big method. 

In Student A's saveGame (FoxHoundIO) we can see that when returning the error character "#" they manually wrote it each time whereas in Student B's code they have made it into an constant. By making it an constant we can easily change the code afterwards if we want to change the return character for load failures we only need to change it at one line rather than multiple lines and in some cases you might miss one. For Student A to fix this, they can simply make an constant with the error character and then call to it each time. 

The declariation of each method is inconsistent for Student A. For example in FoxHoundUtils line 226 we have "public static int[] containElement (int[] intArr, int element){", line 236 we have "public static int[] containElement (int[][] intArr, int[] element) {" and then at line 288 we have " public static int[] validRowsGen(int dimension, char figure, int originRow){". From this we can see that the declaration is not consistent throughout the program. This also does not follow the INF1B coding convention 2.2.3 which states the braces open after a space and the "normal" brackets does not have a space between the name of the method and itself. This could be a simple fix by adding and removing a space where required. This will keep the code consistent and help the user to read them if they know what to expect. For Student B also have similar problem which there is an additional space in the method declaration and a similar fix is recommended. 

For both Student A and Student B the order of declarations all comply with the INF1B coding conventions. This makes it easier for the reader as what they are looking for are always in a similar place in every file rather than all over the place and hard to find. For example all the constants are just under the class declaration, otherwise if they are placed all over the class they can be challenging to find for the reader and changing can be hard too. 
	
Pair 2 - Use of Java Language

In Java we can treat characters like an integer by using its Unicode numerical value. As we can see that this is the approach used by Student B, this doesn't require the creation of an array of characters used within the program and this is much easier for the user to understand what is happening. Whereas Student A is using more hard coded approach where they are creating an array of all possible characters and using it from there. This means an additional variable is created and could have been avoided. 

In Student A's displayBoard they have used an 2D array (or matrix) to display the board whereas in Student B's code they printed it line by line. By using an matrix they can store the board much more easily and can iterate through it easily as well. Compared to using a line by line approach, other methods have to be called multiple times in order for the board to be printed. Also logically this means that printing the board could be simplified as you are just printing an array in a certain format rather than worry about what line you are printing and calling the method with the right values for the line you are printing. 

Overall both Students make use and throwing new exceptions but there are methods which Student A missed out. For example displayBoard() in FoxHoundUI Student A has not checked the input values and throw exceptions if they become invalid. Whereas Student B checks for null pointers and illegal arguments exceptions right at the start of the method. This helps to make sure that no invalid input is passed onto the method and produce and incorrect output. 

From looking at both Student A's and Student B's code we can see that most methods they have written are not replaceable by a simple library functions. This means that they are rewriting code that is already available to the programmers. We could see that when printing error messages they are using the error stream rather than the standard output stream. This seperates the standard output with the error messages. For Student B in FoxHoundUI we can see line 100 they have used "System.out.println(String.format" This can be replaced with the "printf" and this a shorter way of doing the same thing but an "\n" would be required at the end of the string to achieve the new line after each print.

